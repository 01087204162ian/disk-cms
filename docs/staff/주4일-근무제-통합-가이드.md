# 주 4일 근무제 시스템 통합 가이드

**작성일**: 2025-12-28  
**버전**: 2.0  
**최종 업데이트**: 2025-12-28

---

## 목차

1. [시스템 개요](#1-시스템-개요)
2. [기본 규칙](#2-기본-규칙)
3. [사이클 계산 로직](#3-사이클-계산-로직)
4. [휴무일 계산 로직](#4-휴무일-계산-로직)
5. [공휴일 처리](#5-공휴일-처리)
6. [데이터베이스 스키마](#6-데이터베이스-스키마)
7. [API 스펙](#7-api-스펙)
8. [운영 가이드](#8-운영-가이드)
9. [문제 해결](#9-문제-해결)

---

## 1. 시스템 개요

### 1.1 주 4일 근무제 개념

- **근무 주수**: 주 5일 중 4일 근무, 1일 휴무
- **사이클**: 4주 단위로 휴무일이 순환 (시프트)
- **공휴일 처리**: 평일에 공휴일이 있는 주는 해당 주만 주 4일 근무 해제

### 1.2 주요 특징

- ✅ 타임존: 모든 날짜 계산은 KST (Asia/Seoul, UTC+9) 기준
- ✅ 공휴일 주는 사이클에서 제외 (공휴일이 없는 주만 카운트)
- ✅ 사이클 시작일의 주가 공휴일 주면, 다음 공휴일이 아닌 주부터 사이클 시작
- ✅ 주말(토요일, 일요일) 공휴일은 무시 (평일 공휴일만 고려)

---

## 2. 기본 규칙

### 2.1 기본 휴무일 설정

사용자가 기본 휴무일을 설정하면:

```json
{
  "base_off_day": 1,  // 1=월, 2=화, 3=수, 4=목, 5=금
  "cycle_start_date": "2025-12-29",  // 항상 월요일
  "initial_selection_date": "2025-12-28"  // 설정한 날짜
}
```

**규칙**:
1. `cycle_start_date`: 해당 주의 월요일로 자동 설정
2. `base_off_day`: 사용자가 선택한 요일 (1-5)
3. `initial_selection_date`: 설정한 날짜 저장

### 2.2 사이클 구조

- **사이클 0 (1-4주차)**: `base_off_day` 고정 사용
- **사이클 1 (5-8주차)**: 시프트 시작 (금→목→수→화→월 순서)
- **사이클 2 (9-12주차)**: 계속 시프트
- **4주 단위로 순환**: 각 사이클마다 4주(공휴일 주 제외)

---

## 3. 사이클 계산 로직

### 3.1 실제 사이클 시작일 계산

사이클 시작일의 주가 공휴일 주인 경우, 다음 공휴일이 아닌 주부터 실제 사이클이 시작됩니다.

```javascript
// 사이클 실제 시작 주 찾기
let actualCycleStart = startWeekStart;
if (hasHolidayInWeek(actualCycleStart, holidays)) {
  // 공휴일 주를 건너뛰고 다음 공휴일이 아닌 주 찾기
  do {
    actualCycleStart = new Date(actualCycleStart);
    actualCycleStart.setDate(actualCycleStart.getDate() + 7);
  } while (hasHolidayInWeek(actualCycleStart, holidays));
}
```

### 3.2 사이클 번호 계산

공휴일이 없는 주만 카운트하여 사이클 번호를 계산합니다.

```javascript
// 실제 사이클 시작일부터 목표 날짜까지 주를 순회
let weekCount = 0;  // 공휴일이 없는 주의 개수
let cycleNumber = 0;

while (currentWeekStart <= targetWeekStart) {
  // 공휴일 주가 아닌 경우에만 카운트
  if (!hasHolidayInWeek(currentWeekStart, holidays)) {
    weekCount++;
    
    // weekCount가 4를 넘으면 다음 사이클로
    // weekCount === 5일 때 사이클 1, weekCount === 9일 때 사이클 2
    if (weekCount > 4) {
      cycleNumber = Math.floor((weekCount - 1) / 4);
    }
  }
  
  // 다음 주로 이동
  currentWeekStart.setDate(currentWeekStart.getDate() + 7);
}
```

**예시**:
- 사이클 시작일: 2025-12-29 (월요일, 공휴일 주 - 2026-01-01 포함)
- 실제 사이클 시작: 2026-01-05 (월요일, 공휴일 없는 주)
- 2026-01-05: weekCount=1, cycleNumber=0 (1주차)
- 2026-01-12: weekCount=2, cycleNumber=0 (2주차)
- 2026-01-19: weekCount=3, cycleNumber=0 (3주차)
- 2026-01-26: 공휴일 주 (제외)
- 2026-02-02: weekCount=4, cycleNumber=0 (4주차)
- 2026-02-09: weekCount=5, cycleNumber=1 (사이클 1, 1주차)

---

## 4. 휴무일 계산 로직

### 4.1 시프트 순서

```
금요일(5) → 목요일(4) → 수요일(3) → 화요일(2) → 월요일(1) → 금요일(5) (순환)
```

### 4.2 휴무일 계산 공식

```javascript
// 사이클 0인 경우 base_off_day 사용
if (cycleNumber === 0) {
  return baseOffDay;
}

// 시프트 순서 배열
const shiftOrder = [5, 4, 3, 2, 1]; // 금, 목, 수, 화, 월

// base_off_day의 시프트 순서 내 인덱스 찾기
const baseIndex = shiftOrder.indexOf(baseOffDay);

// 사이클 번호에 따른 시프트 인덱스 계산
// 각 사이클마다 시프트 순서에서 4칸 앞으로 이동
// 사이클 1: baseIndex - 4, 사이클 2: baseIndex - 8
const shiftIndex = ((baseIndex - cycleNumber * 4) % 5 + 5) % 5;

// 현재 사이클의 휴무일
const currentOffDay = shiftOrder[shiftIndex];
```

### 4.3 사이클별 휴무일 예시 (base_off_day = 1, 월요일)

| 사이클 | 주차 범위 | 휴무일 | 계산 |
|--------|----------|--------|------|
| 0 | 1-4주차 | 월요일(1) | base_off_day 고정 |
| 1 | 5-8주차 | 금요일(5) | baseIndex(4) - 4 = 0 → shiftOrder[0] = 5 |
| 2 | 9-12주차 | 목요일(4) | baseIndex(4) - 8 = -4 → shiftOrder[1] = 4 |
| 3 | 13-16주차 | 수요일(3) | baseIndex(4) - 12 = -8 → shiftOrder[2] = 3 |
| 4 | 17-20주차 | 화요일(2) | baseIndex(4) - 16 = -12 → shiftOrder[3] = 2 |
| 5 | 21-24주차 | 월요일(1) | baseIndex(4) - 20 = -16 → shiftOrder[4] = 1 |

---

## 5. 공휴일 처리

### 5.1 공휴일 주 판단 규칙

**중요**: 주말(토요일, 일요일)에 있는 공휴일은 무시합니다.

```javascript
function hasHolidayInWeek(weekStartDate, holidays) {
  // ... 주 범위 확인 ...
  
  return holidays.some(h => {
    const holidayDate = parseKSTDate(h.date);
    
    // 주말(토요일=6, 일요일=0)에 있는 공휴일은 제외
    const dayOfWeek = holidayDate.getDay();
    if (dayOfWeek === 0 || dayOfWeek === 6) {
      return false; // 주말 공휴일은 무시
    }
    
    // 평일 공휴일만 확인
    return holidayDateStr >= weekStartStr && holidayDateStr <= weekEndStr;
  });
}
```

**예시**:
- 2026-03-01 (삼일절, 일요일) → 공휴일 주가 아님 ✅
- 2026-01-01 (신정, 목요일) → 공휴일 주 ✅

### 5.2 공휴일 주 처리

- **공휴일 주**: 해당 주의 모든 날짜가 `is_off_day: false` (주 4일 근무 해제)
- **사이클 계산**: 공휴일 주는 사이클에서 제외 (카운트하지 않음)
- **다음 사이클**: 공휴일 주를 건너뛰고 다음 공휴일이 아닌 주부터 계산

---

## 6. 데이터베이스 스키마

### 6.1 users 테이블 - work_days 컬럼

```json
{
  "base_off_day": 1,  // 기본 휴무일 (1=월, 2=화, 3=수, 4=목, 5=금)
  "cycle_start_date": "2025-12-29",  // 사이클 시작일 (항상 월요일)
  "initial_selection_date": "2025-12-28"  // 초기 선택 날짜
}
```

### 6.2 holidays 테이블

```sql
CREATE TABLE holidays (
  id INT PRIMARY KEY AUTO_INCREMENT,
  holiday_date DATE NOT NULL UNIQUE,
  name VARCHAR(100) NOT NULL,
  year INT NOT NULL,
  is_active TINYINT(1) DEFAULT 1,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**필수 공휴일**:
- 고정 공휴일: 신정(1/1), 삼일절(3/1), 어린이날(5/5), 현충일(6/6), 광복절(8/15), 개천절(10/3), 한글날(10/9), 성탄절(12/25)
- 음력 공휴일: 설날, 추석, 부처님오신날 (매년 수동 추가 필요)

---

## 7. API 스펙

### 7.1 개인 스케줄 조회

```
GET /api/staff/work-schedules/my-schedule/:year/:month
```

**응답 예시**:
```json
{
  "success": true,
  "data": {
    "year": 2026,
    "month": 2,
    "current_cycle": {
      "cycle_number": 0,
      "off_day": 1,
      "off_day_name": "월요일",
      "week_range": "1-4주차",
      "cycle_start_date": "2025-12-29",
      "next_cycle_date": "2026-02-09",
      "next_off_day": 5,
      "next_off_day_name": "금요일"
    },
    "daily_schedule": [
      {
        "date": "2026-02-02",
        "day_of_week": 1,
        "off_day": 1,
        "is_off_day": true,
        "is_holiday": false,
        "has_half_day": false
      }
    ]
  }
}
```

### 7.2 주요 헬퍼 함수

**파일**: `routes/staff/work-schedule-helpers.js`

- `getCycleNumber(cycleStartDate, targetDate, holidays)`: 사이클 번호 계산
- `getCycleWeek(cycleStartDate, targetDate, holidays)`: 사이클 내 주차 계산 (1-4)
- `calculateOffDayByWeekCycle(cycleStartDate, targetDate, baseOffDay, holidays)`: 휴무일 계산
- `hasHolidayInWeek(weekStartDate, holidays)`: 공휴일 주 판단
- `calculateCycleInfo(workDays, targetDate, holidays)`: 사이클 정보 계산

---

## 8. 운영 가이드

### 8.1 매년 말 작업 (12월)

#### 1단계: 다음 해 공휴일 확인
```sql
SELECT * FROM holidays 
WHERE year = YEAR(CURDATE()) + 1 
ORDER BY holiday_date;
```

#### 2단계: 고정 공휴일 자동 생성
```sql
-- database/auto-generate-holidays.sql 실행
```

#### 3단계: 음력 공휴일 수동 추가
- 설날: 음력 1월 1일
- 추석: 음력 8월 15일
- 부처님오신날: 음력 4월 8일

### 8.2 공휴일 조회 범위

API에서 공휴일 조회 시 ±1년 범위로 확장:

```javascript
const queryStartDate = new Date(firstDayWeekStart);
queryStartDate.setFullYear(queryStartDate.getFullYear() - 1); // 1년 전까지

const queryEndDateExtended = new Date(queryEndDate);
queryEndDateExtended.setFullYear(queryEndDateExtended.getFullYear() + 1); // 1년 후까지
```

---

## 9. 문제 해결

### 9.1 공통 문제

#### 문제 1: 사이클 번호가 잘못 계산됨

**원인**: 공휴일 주가 제대로 제외되지 않음

**해결**:
1. `hasHolidayInWeek` 함수가 주말 공휴일을 제외하는지 확인
2. 공휴일 데이터가 올바르게 저장되어 있는지 확인

#### 문제 2: 휴무일이 잘못 계산됨

**원인**: 시프트 계산 로직 오류

**해결**:
```javascript
// 올바른 계산 공식
const shiftIndex = ((baseIndex - cycleNumber * 4) % 5 + 5) % 5;
```

#### 문제 3: 다음 사이클 시작일이 잘못됨

**원인**: 공휴일 주를 고려하지 않음

**해결**:
- `calculateCycleInfo` 함수에서 다음 사이클 시작일을 계산할 때 공휴일 주를 건너뛰어야 함

### 9.2 디버깅

#### 로그 확인
```
[getCycleNumber] cycleStart: 2025-12-29, actualCycleStart: 2026-01-05, target: 2026-02-09, weekCount: 5, cycleNumber: 1
[calculateOffDayByWeekCycle] weekStart: 2026-02-09, isHolidayWeek: false, cycleNumber: 1, baseOffDay: 1
```

#### 캐시 문제
- 주 단위로 `offDay`를 캐싱하여 중복 계산 방지
- 같은 주의 모든 날짜에 대해 한 번만 계산

---

## 10. 핵심 요약

### ✅ 주요 규칙

1. **사이클 시작일**: 항상 월요일, 공휴일 주면 다음 공휴일이 아닌 주부터 시작
2. **공휴일 주 판단**: 평일(월~금) 공휴일만 고려, 주말 공휴일 무시
3. **사이클 계산**: 공휴일 주는 제외하고 4주 단위로 카운트
4. **휴무일 계산**: 사이클 0은 base_off_day 고정, 사이클 1 이상은 시프트 (금→목→수→화→월)
5. **타임존**: 모든 날짜 계산은 KST (Asia/Seoul) 기준

### ✅ 공식

**사이클 번호**:
```
weekCount = 공휴일이 없는 주의 개수 (actualCycleStart부터 targetWeekStart까지)
cycleNumber = floor((weekCount - 1) / 4)
```

**휴무일**:
```
사이클 0: base_off_day
사이클 1 이상: shiftOrder[(baseIndex - cycleNumber * 4) % 5]
```

---

**문서 버전**: 2.0  
**최종 업데이트**: 2025-12-28  
**작성자**: 시스템 개발팀

