# 주 4일 근무제 CMS 개발 기획서

**작성일**: 2025-12-28  
**버전**: 1.0  
**목적**: 4주 단위 운영 + 타임존 기준 명확화

---

## 1. 목적

본 기획서는 주 4일 근무제를 4주 사이클 기준으로 안정적으로 운영하기 위한 CMS 기능을 정의하고, 특히 타임존(Timezone)으로 인한 근무일·휴무일 오판 리스크를 원천 차단하는 것을 목적으로 한다.

---

## 2. 핵심 운영 전제 (절대 변경 불가)

### 2.1 기본 운영 단위
- **기본 운영 단위는 4주**
- 모든 근무·휴무·반차·공휴일 판단은 **KST (Asia/Seoul, UTC+9) 기준으로만 계산**
- 서버, DB, 클라이언트 간 타임존 불일치로 인한 날짜 오류는 **시스템 결함으로 간주**

---

## 3. 타임존 설계 원칙 (중요)

### 3.1 기준 타임존
- **기준 타임존**: Asia/Seoul (UTC+09:00)
- 모든 날짜 판단 로직은 반드시 KST 기준으로 수행

### 3.2 서버/DB/프론트 규칙

| 구분 | 규칙 |
|------|------|
| 서버(Node.js) | 내부 계산은 UTC 저장 + KST 변환 계산 |
| DB | DATETIME 또는 TIMESTAMP + timezone 명시 |
| 프론트엔드 | 서버에서 내려준 KST 기준 날짜만 표시 |
| 금지 | 브라우저 로컬 타임존 기준 날짜 계산 ❌ |

⚠️ **프론트에서 `new Date()`로 날짜 판단 금지**
(사용자 PC 타임존 차이로 휴무일 오류 발생 가능)

### 3.3 구현 방법
- 서버에서 모든 날짜 계산 수행
- 클라이언트는 서버에서 계산한 결과만 표시
- 날짜 비교는 항상 서버에서 KST 기준으로 수행

---

## 4. 4주 사이클 정의

### 4.1 사이클 기준일
- 기준 시작일(`cycle_start_date`)은 관리자가 지정
- 기준일은 항상 **KST 00:00:00**
- 예: `cycle_start_date = 2025-01-06 00:00:00 (KST, 월요일)`

### 4.2 사이클 계산 로직
```
cycle_number = floor( (KST_today - cycle_start_date) / 28일 )
cycle_day_index = (KST_today - cycle_start_date) % 28
```

- **28일 = 4주 고정**
- **월 단위 계산 절대 사용 금지**

### 4.3 사이클 정보 저장
- `users.work_days` JSON 필드에 저장:
  ```json
  {
    "base_off_day": 5,  // 1=월, 2=화, 3=수, 4=목, 5=금
    "cycle_start_date": "2025-01-06",  // KST 기준
    "initial_selection_date": "2025-01-06"  // 최초 선택일
  }
  ```

---

## 5. 휴무일 로직

### 5.1 기본 휴무일
- 직원은 4주 단위로 1일 휴무 요일 선택
- 선택 값: `MON(1) | TUE(2) | WED(3) | THU(4) | FRI(5)`
- 해당 요일은 4주 동안 고정

### 5.2 관리자 조정
- 관리자는 사이클 내 휴무 요일 변경 가능
- 변경 시 필수 기록:
  - 변경 전/후
  - 변경 사유
  - 변경 일시(KST)

### 5.3 휴무일 계산 함수
```javascript
/**
 * 4주 사이클 기준 휴무일 계산
 * @param {Date} cycleStartDate - 사이클 시작일 (KST)
 * @param {Date} targetDate - 계산 대상 날짜 (KST)
 * @param {number} baseOffDay - 기본 휴무일 (1-5)
 * @returns {number} 해당 날짜의 휴무일 (1-5)
 */
function calculateOffDay(cycleStartDate, targetDate, baseOffDay) {
  // KST 기준 날짜 차이 계산
  const daysDiff = Math.floor((targetDate - cycleStartDate) / (1000 * 60 * 60 * 24));
  const cycleNumber = Math.floor(daysDiff / 28);
  
  // 시프트 계산 (금→목→수→화→월→금)
  const shiftOrder = [5, 4, 3, 2, 1]; // 금, 목, 수, 화, 월
  const shiftIndex = cycleNumber % 5;
  const currentOffDay = shiftOrder[shiftIndex];
  
  return currentOffDay;
}
```

---

## 6. 공휴일 포함 주 처리 로직

### 6.1 규칙
- 공휴일이 포함된 주는 해당 주만 **주 4일 근무 해제**
- 사이클(4주)은 유지됨

### 6.2 계산 기준
- 공휴일 판단 기준:
  ```sql
  holiday_date BETWEEN week_start AND week_end
  ```
- 모든 날짜 비교는 **KST 기준**

### 6.3 주 기준 정의
```
week_start = 월요일 00:00:00 (KST)
week_end   = 일요일 23:59:59 (KST)
```

### 6.4 구현 로직
```javascript
/**
 * 주 시작일 계산 (월요일 00:00:00 KST)
 * @param {Date} date - 기준 날짜 (KST)
 * @returns {Date} 주 시작일 (월요일 00:00:00 KST)
 */
function getWeekStartDate(date) {
  const kstDate = new Date(date);
  const dayOfWeek = kstDate.getDay(); // 0=일, 1=월, ..., 6=토
  const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
  
  const weekStart = new Date(kstDate);
  weekStart.setDate(kstDate.getDate() - daysToMonday);
  weekStart.setHours(0, 0, 0, 0);
  
  return weekStart;
}

/**
 * 주에 공휴일이 포함되어 있는지 확인
 * @param {Date} weekStartDate - 주 시작일 (월요일, KST)
 * @param {Array} holidays - 공휴일 배열 [{date: Date, name: string}]
 * @returns {boolean} 공휴일 포함 여부
 */
function hasHolidayInWeek(weekStartDate, holidays) {
  const weekEnd = new Date(weekStartDate);
  weekEnd.setDate(weekStartDate.getDate() + 6); // 일요일
  weekEnd.setHours(23, 59, 59, 999);
  
  return holidays.some(holiday => {
    const holidayDate = new Date(holiday.date);
    return holidayDate >= weekStartDate && holidayDate <= weekEnd;
  });
}
```

---

## 7. 휴무 시프트(순환) 로직

### 7.1 시프트 규칙
- 4주 단위로 휴무 요일이 순환됨
- 순환 순서: **금 → 목 → 수 → 화 → 월 → (다시 금)**

### 7.2 시프트 계산 예시
```
shift_index = cycle_number % 5
rest_day = shift_order[shift_index]
```

### 7.3 시프트 순서
```javascript
const SHIFT_ORDER = [5, 4, 3, 2, 1]; // 금, 목, 수, 화, 월
```

### 7.4 예시
```
사이클 0 (1-4주): 금요일 휴무
사이클 1 (5-8주): 목요일 휴무
사이클 2 (9-12주): 수요일 휴무
사이클 3 (13-16주): 화요일 휴무
사이클 4 (17-20주): 월요일 휴무
사이클 5 (21-24주): 금요일 휴무 (순환 복귀)
```

---

## 8. 반차 처리 로직

### 8.1 기본 규칙
- 휴무 1일 = 반차 2회
- 반차는 휴무일 분할 사용 개념

### 8.2 반차 종류
- **오전 반차 (HALF_AM)**: 오후 14시 출근 (오후 4시간 근무)
- **오후 반차 (HALF_PM)**: 오후 14시 퇴근 (오전 4시간 근무)

### 8.3 제한 조건
- 동일 주 과도 사용 제한
- 반차 + 휴무일 중복 불가
- 반차는 같은 주(월~일) 내에서만 사용 가능

### 8.4 승인
- 반차 사용은 팀장 승인 필수
- 승인/반려 로그 필수 저장

### 8.5 반차 검증 로직
```javascript
/**
 * 반차 신청 검증
 * @param {Date} applyDate - 신청 날짜 (KST)
 * @param {Date} userOffDay - 사용자 휴무일 (KST)
 * @param {Array} holidays - 공휴일 배열
 * @returns {Object} {valid: boolean, message: string}
 */
function validateHalfDay(applyDate, userOffDay, holidays) {
  // 1. 공휴일인지 확인
  const isHoliday = holidays.some(h => {
    return formatDate(h.date) === formatDate(applyDate);
  });
  if (isHoliday) {
    return { valid: false, message: '공휴일에는 반차를 사용할 수 없습니다.' };
  }
  
  // 2. 휴무일인지 확인
  const weekStart = getWeekStartDate(applyDate);
  const offDay = calculateOffDay(cycleStartDate, weekStart, baseOffDay);
  if (applyDate.getDay() === offDay) {
    return { valid: false, message: '휴무일에는 반차를 사용할 수 없습니다.' };
  }
  
  // 3. 같은 주인지 확인
  const applyWeekStart = getWeekStartDate(applyDate);
  const offDayWeekStart = getWeekStartDate(userOffDay);
  if (formatDate(applyWeekStart) !== formatDate(offDayWeekStart)) {
    return { valid: false, message: '반차는 같은 주(월~일) 내에서만 사용 가능합니다.' };
  }
  
  return { valid: true, message: '검증 통과' };
}
```

---

## 9. 데이터베이스 스키마 설계

### 9.1 users 테이블 (기존)
```sql
ALTER TABLE users ADD COLUMN IF NOT EXISTS work_days JSON DEFAULT NULL 
COMMENT '주4일 근무제 정보: {base_off_day, cycle_start_date, initial_selection_date}';
```

**work_days JSON 구조**:
```json
{
  "base_off_day": 5,  // 1=월, 2=화, 3=수, 4=목, 5=금
  "cycle_start_date": "2025-01-06",  // KST 기준
  "initial_selection_date": "2025-01-06"  // 최초 선택일
}
```

### 9.2 work_schedules 테이블 (기존)
- 월별 스케줄 정보 저장
- `temporary_change` JSON 필드로 일시적 변경 기록

### 9.3 schedule_changes 테이블 (기존)
- 일시적 휴무일 변경 이력 저장
- 승인/반려 상태 관리

### 9.4 leaves 테이블 (기존)
- 반차 신청 정보 저장
- `leave_type`: `HALF_AM`, `HALF_PM`

### 9.5 holidays 테이블 (기존)
- 공휴일 정보 저장
- `holiday_date`: DATE 타입 (KST 기준)

---

## 10. API 설계

### 10.1 사용자 스케줄 조회
```
GET /api/staff/work-schedules/my-schedule/:year/:month
Response: {
  "success": true,
  "data": {
    "year": 2025,
    "month": 12,
    "user": {
      "email": "user@example.com",
      "work_days": {
        "base_off_day": 5,
        "cycle_start_date": "2025-01-06"
      }
    },
    "current_cycle": {
      "cycle_number": 11,
      "off_day": 4,
      "off_day_name": "목요일",
      "week_range": "1-4주차"
    },
    "daily_schedule": [
      {
        "date": "2025-12-01",
        "day_of_week": 1,
        "off_day": 4,
        "is_off_day": false,
        "is_holiday": false,
        "has_half_day": false
      },
      ...
    ],
    "holidays": [
      {"date": "2025-12-25", "name": "크리스마스"}
    ],
    "is_probation": false,
    "has_holiday_in_week": false
  }
}
```

### 10.2 반차 신청
```
POST /api/staff/work-schedules/apply-half-day
Body: {
  "date": "2025-12-15",  // KST 기준
  "leave_type": "HALF_AM" | "HALF_PM",
  "reason": "개인 사정"
}
```

### 10.3 일시적 휴무일 변경
```
POST /api/staff/work-schedules/temporary-change
Body: {
  "week_start_date": "2025-12-15",  // KST 기준
  "temporary_off_day": 3,  // 1-5
  "reason": "개인 사정",
  "substitute_employee": "substitute@example.com"
}
```

---

## 11. 개발 단계

### Phase 1: 기획 및 설계 ✅
- [x] 요구사항 정리
- [x] 타임존 설계 원칙 수립
- [x] 데이터베이스 스키마 설계
- [x] API 설계

### Phase 2: 백엔드 개발
- [ ] 타임존 헬퍼 함수 구현
- [ ] 4주 사이클 계산 함수 구현
- [ ] 휴무일 계산 함수 구현
- [ ] 공휴일 포함 주 체크 함수 구현
- [ ] 반차 검증 함수 구현
- [ ] API 엔드포인트 구현

### Phase 3: 프론트엔드 개발
- [ ] 스케줄 조회 페이지
- [ ] 캘린더 표시 (서버 데이터 기반)
- [ ] 반차 신청 모달
- [ ] 일시적 변경 신청 모달

### Phase 4: 테스트
- [ ] 타임존 테스트
- [ ] 사이클 계산 테스트
- [ ] 공휴일 처리 테스트
- [ ] 반차 검증 테스트

---

## 12. 주의사항

### 12.1 타임존 처리
- ⚠️ **절대 금지**: 프론트엔드에서 `new Date()`로 날짜 계산
- ✅ **권장**: 모든 날짜 계산은 서버에서 수행하고 결과만 전달

### 12.2 날짜 비교
- 모든 날짜 비교는 KST 기준으로 수행
- `Date` 객체 생성 시 명시적으로 KST 시간대 지정

### 12.3 사이클 계산
- 월 단위 계산 절대 사용 금지
- 항상 28일(4주) 기준으로 계산

---

**문서 버전**: 1.0  
**최종 업데이트**: 2025-12-28

