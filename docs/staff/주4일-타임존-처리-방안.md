# 주4일 근무제 시스템 - 타임존 처리 방안

**작성일**: 2025-01-XX  
**목적**: 프론트엔드 vs 백엔드 계산 위치에 대한 분석 및 개선 방안

---

## 📋 현재 구조

### 현재 방식: 프론트엔드에서 계산

**장점**:
1. ✅ 서버 부하 감소
   - 캘린더의 모든 날짜(31일)를 계산하는 것은 많은 CPU 사용
   - 월별 스케줄 조회 시 한 번만 API 호출
   
2. ✅ 실시간 UI 업데이트
   - 월 변경 시 즉시 계산 가능
   - 서버 요청 없이 UI 업데이트 가능
   
3. ✅ 오프라인 지원
   - 모킹 데이터 사용 시 오프라인에서도 작동
   - 네트워크 오류 시에도 기본 기능 유지

**단점**:
1. ❌ 타임존 문제
   - 클라이언트의 타임존에 따라 결과가 달라질 수 있음
   - `new Date()` 생성 시 타임존 변환 문제
   - 브라우저마다 다르게 동작할 수 있음
   
2. ❌ 계산 로직 중복
   - 프론트엔드와 백엔드에 동일한 로직 존재
   - 유지보수 비용 증가
   - 버그 발생 시 두 곳 모두 수정 필요
   
3. ❌ 보안 취약점
   - 클라이언트에서 계산 로직 노출
   - 악의적인 사용자가 조작 가능 (하지만 이 경우는 큰 문제 아님)

---

## 🔄 개선 방안: 하이브리드 접근

### 추천 방식: 서버에서 월별 날짜 정보 계산 후 반환

**구조**:
```
서버: 월별 각 날짜의 휴무일 정보 계산 → JSON 반환
프론트엔드: 서버에서 받은 데이터를 그대로 표시
```

**장점**:
1. ✅ 타임존 문제 해결
   - 서버는 UTC 또는 고정 타임존 사용
   - 모든 클라이언트에서 동일한 결과 보장
   
2. ✅ 계산 로직 일관성
   - 서버에서만 계산 로직 유지
   - 버그 수정 시 한 곳만 수정
   
3. ✅ 데이터 정확성
   - 서버가 Single Source of Truth
   - 클라이언트 조작 불가능

**단점**:
1. ⚠️ 서버 부하 증가
   - 월별 31일 계산 (하지만 이 정도는 미미함)
   - 캐싱으로 해결 가능
   
2. ⚠️ 네트워크 트래픽 증가
   - 월별 데이터 크기 증가 (하지만 JSON으로는 작음)
   - 압축으로 해결 가능

---

## 💡 권장 구현 방안

### Option 1: 서버에서 월별 날짜 정보 반환 (추천) ⭐

**서버 응답 구조**:
```json
{
  "success": true,
  "data": {
    "year": 2025,
    "month": 12,
    "daily_schedule": [
      {
        "date": "2025-12-01",
        "day_of_week": 1,
        "off_day": 4,
        "is_off_day": false,
        "is_holiday": false,
        "has_half_day": false
      },
      {
        "date": "2025-12-04",
        "day_of_week": 4,
        "off_day": 4,
        "is_off_day": true,
        "is_holiday": false,
        "has_half_day": false
      }
      // ... 31일치
    ]
  }
}
```

**장점**:
- 타임존 문제 완전 해결
- 계산 로직 일관성 보장
- 프론트엔드는 단순 렌더링만 수행

**단점**:
- API 응답 크기 증가 (하지만 압축하면 미미함)
- 서버 부하 약간 증가 (하지만 캐싱 가능)

---

### Option 2: 현재 방식 유지 + 타임존 처리 개선

**개선 사항**:
1. 모든 날짜 계산을 UTC 기준으로 통일
2. `new Date(year, month, day)` 형식 사용 (로컬 타임존 무시)
3. 서버와 동일한 로직 보장

**장점**:
- 현재 구조 유지
- 서버 부하 없음

**단점**:
- 타임존 처리 복잡도 증가
- 여전히 계산 로직 중복

---

## 🎯 최종 권장 사항

### **서버에서 월별 날짜 정보 계산 후 반환 (Option 1) 추천** ⭐⭐⭐

**이유**:
1. **타임존 문제 완전 해결**: 서버는 UTC 기준으로 계산하여 일관성 보장
2. **유지보수성 향상**: 계산 로직을 한 곳에서만 관리
3. **데이터 정확성**: 서버가 Single Source of Truth
4. **성능 영향 미미**: 월별 31일 계산은 매우 가벼운 작업
5. **캐싱 가능**: 월별 데이터는 캐싱하여 성능 최적화 가능

**구현 복잡도**: 중간
- 서버: 월별 날짜 정보 계산 로직 추가
- 프론트엔드: 서버 데이터를 그대로 표시하도록 수정

---

## 📊 성능 비교

| 항목 | 현재 (프론트엔드) | 개선 (서버) |
|------|------------------|------------|
| 서버 부하 | 낮음 | 중간 (캐싱 시 낮음) |
| 네트워크 트래픽 | 낮음 | 중간 (압축 시 낮음) |
| 타임존 문제 | 있음 | 없음 |
| 계산 정확성 | 중간 | 높음 |
| 유지보수성 | 낮음 | 높음 |

---

## 🔧 구현 예시

### 서버 측 (work-schedules.js)

```javascript
// 월별 각 날짜의 스케줄 정보 계산
const dailySchedule = [];
const daysInMonth = new Date(year, month, 0).getDate();

for (let day = 1; day <= daysInMonth; day++) {
  const date = new Date(year, month - 1, day);
  const dayOfWeek = date.getDay();
  
  if (dayOfWeek >= 1 && dayOfWeek <= 5) { // 평일만
    const weekStart = getWeekStartDate(date);
    const offDay = calculateOffDayByWeekCycle(
      workDays.cycle_start_date,
      weekStart,
      workDays.base_off_day
    );
    
    const dateStr = formatDate(date);
    const isHoliday = holidays.some(h => h.date === dateStr);
    const hasHalfDay = halfDayRows.some(h => h.start_date.split('T')[0] === dateStr);
    
    dailySchedule.push({
      date: dateStr,
      day_of_week: dayOfWeek,
      off_day: offDay,
      is_off_day: dayOfWeek === offDay && !isHoliday,
      is_holiday: isHoliday,
      has_half_day: hasHalfDay
    });
  }
}
```

### 프론트엔드 측 (employee-schedule.js)

```javascript
// 서버에서 받은 daily_schedule을 그대로 사용
if (scheduleData.daily_schedule) {
  scheduleData.daily_schedule.forEach(dayInfo => {
    // dayInfo를 그대로 사용하여 캘린더 생성
  });
}
```

---

## ✅ 결론

**서버에서 계산하는 것이 더 나은 선택입니다.**

1. **타임존 문제 해결**: 가장 큰 장점
2. **유지보수성**: 계산 로직을 한 곳에서만 관리
3. **정확성**: 서버가 Single Source of Truth
4. **성능**: 월별 계산은 가벼운 작업이며 캐싱 가능

현재 타임존 문제로 인한 버그를 해결하려면, 서버에서 월별 날짜 정보를 계산하여 반환하는 방식으로 개선하는 것을 권장합니다.

---

**문서 버전**: 1.0  
**최종 업데이트**: 2025-01-XX

